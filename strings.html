<html>
  <head>
    <meta charset="utf-8" />
  </head>

  <body>
    <script>
      const align = (p) => 4 * (((p + 3) / 4) | 0);

      const interop = (instance, methodName, ...args) => {
        const {
          exports: { memory },
        } = instance;

        let required = 0;
        for (const arg of args) {
          if (typeof arg === "object" && "byteLength" in arg) {
            required += align(arg.byteLength);
          }
        }

        // get current size
        const needed = Math.ceil(required / (256 * 256));
        if (needed > 2) {
          memory.grow(needed - 2);
        }

        const bytes = new Uint8Array(
          memory.buffer,
          0,
          memory.buffer.byteLength
        );

        const raw = [];
        let p = 4;
        for (const arg of args) {
          if (typeof arg === "object" && "byteLength" in arg) {
            raw.push(p);
            const t = new Uint8Array(
              arg.buffer,
              arg.byteOffset,
              arg.byteLength
            );
            for (let i = 0; i < arg.byteLength; i++) {
              bytes[p + i] = t[i];
            }

            p += align(arg.byteLength);
          } else {
            raw.push(arg);
          }
        }

        const result = instance.exports[methodName](...raw);

        // writeback
        p = 4;
        for (const arg of args) {
          if (typeof arg === "object" && "byteLength" in arg) {
            const t = new Uint8Array(
              arg.buffer,
              arg.byteOffset,
              arg.byteLength
            );
            for (let i = 0; i < arg.byteLength; i++) {
              t[i] = bytes[p + i];
            }

            p += align(arg.byteLength);
          }
        }

        return result;
      };

      const compactJS = (instance, target, offsets, count, source) => {
        const SIZE = 65536;

        return interop(
          instance,
          "compact",
          target,
          offsets,
          count,
          source,
          new Uint32Array(SIZE)
        );
      };

      WebAssembly.instantiateStreaming(fetch("./strings.c.wasm"), {}).then(
        (result) => {
          const dataX = ["Hello", "World", "Hello", "World", "Hello"];
          const data = new Array(1e5)
            .fill(0)
            .map(() => Math.random().toString(16).substring(11));

          const strings = new Uint32Array(data.length);
          const source = new Uint8Array(6 * data.length);

          let p = 0;
          for (let i = 0; i < data.length; i += 1) {
            const value = data[i];
            strings[i] = p;

            const encoded = new TextEncoder().encode(value); // encode into?
            for (let j = 0; j < encoded.byteLength; j += 1) {
              source[p] = encoded[j];
              p += 1;
            }

            source[p] = 0xff;
            p += 1;
          }

          const s = performance.now();
          const target = new Uint8Array(source.byteLength);
          const targetLen = compactJS(
            result.instance,
            target,
            strings,
            data.length,
            source
          );
          console.log(`Size: ${p} -> ${targetLen}`);
          console.log("Time taken: ", performance.now() - s);

          for (let i = 0; i < Math.min(16, data.length); i += 1) {
            const p = strings[i];

            // get string length
            let n = 0;
            while (target[p + n] !== 0xff) n += 1;

            const encoded = new Uint8Array(n);
            for (let j = 0; j < n; j += 1) {
              encoded[j] = target[p + j];
            }
            console.log(new TextDecoder().decode(encoded));
          }
        }
      );
    </script>
  </body>
</html>
